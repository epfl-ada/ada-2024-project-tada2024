scheme multi-paradigm program languag . dialect lisp support function procedur program . develop guy l. steel gerald jay sussman 1970 . scheme introduc academ world via seri paper refer sussman steel 's lambda paper . two standard defin scheme languag : offici ieee standard , de facto standard call revis n report algorithm languag scheme , nearli alway abbrevi r n rs , n number revis . current standard r5r , r6r develop . scheme 's philosophi minimalist . scheme provid primit notion possibl , , practic , let everyth els provid program librari . scheme first dialect lisp choos static ( a.k.a . lexic ) dynam variabl scope . also one first program languag support first-class continu . # # origin scheme start attempt understand carl hewitt 's actor model . scheme origin call `` schemer '' , tradit lisp-deriv languag like planner conniv . current name result author ' use oper system , limit filenam two compon six charact . current , `` schemer '' commonli use refer scheme programm . # # futur new languag standard process began 2003 scheme workshop , goal produc r6r standard 2006 . break earlier rnr approach unanim . r6r featur standard modul system ; allow split core languag librari . # # distinguish featur scheme minimalist languag . current languag standard 50 page , includ denot semant languag core . next revis standard expand describ sever librari . like lisp dialect , scheme littl syntax . oper preced rule fulli nest parenthes notat use compound form . scheme 's macro system allow user add new syntact construct languag . respect lexic scope rest languag , avoid common program error occur macro system program languag . procedur scheme first-class valu , allow function program . scheme 's call-with-current-continu oper allow user creat non-loc control construct must built languag , iter , co-routin , backtrack . # # languag element # # # comment comment preced semicolon ( ; ) extend rest line . implement allow comment span multipl line wrap # | ... | # ( possibl nest ) . implement allow entir s-express comment prepend # ; . # # # variabl variabl dynam type . variabl bound defin , let express , scheme form . variabl bound top level defin global scope . ( defin var1 valu ) variabl bound let scope bodi let . ( let ( ( var1 valu ) ) ... ; scope var1 ... ) # # # function 1 ( defin fun ( lambda ( arg1 arg2 ) ... ) ) 2 ( defin ( fun arg1 arg2 ) ... ) 3 ( fun value1 value2 ) 4 ( appli fun ( list value1 value2 ) ) function first-class object scheme . argument function return . assign variabl . exampl function two argument arg1 arg2 defin line 1 line 2 abbrevi . line 3 show function appli . note function appli first posit list rest list contain argument . appli function take first argument appli given list argument , previou function call also written seen line 4 . scheme , function divid two basic categori : procedur primit . primit procedur , procedur primit . primit pre-defin function scheme languag . includ + , - , * , / , set ! , car , cdr , basic procedur . procedur user-defin function . sever variat scheme , user redefin primit . exampl , code ( defin ( + x ) ( - x ) ) simpli ( defin + - ) actual redefin + primit perform subtract , rather addit . # # # list scheme us link list data structur form exist lisp . `` list '' build new link list structur , exampl : ( list 1 2 3 ) ( list ( list 1 2 ) 3 ) '' car '' ( pronounc : [ k� ` r ] listen ) give valu head node list , exampl : ( car ( list 1 2 3 ) ) give 1 ( car ( list ( list 1 2 ) 3 ) ) give ( 1 2 ) '' cdr '' ( pronounc `` could-er '' [ 'kədər listen ] [ 'kudər ] ) give list head node , exampl : ( cdr ( list 1 2 3 ) ) give ( 2 3 ) ( cdr ( list ( list 1 2 ) 3 ) give ( 3 ) '' con '' construct new list given car valu cdr list , exampl : ( con 1 ( list 2 3 ) ) give ( 1 2 3 ) ( con ( list 1 2 ) ( list 3 ) ) give ( ( 1 2 ) 3 ) node link list con cell , also call pair . name pair impli , con cell consist two valu : first one car , second cdr . ( list 1 2 3 ) three con cell , pair . first con cell number 1 first slot , pointer second con cell second . second con cell number 2 first slot , pointer third con cell second slot . third con cell number 3 first slot null constant second slot . null constant usual repres ' ( ) ( quot ( ) ) . con function construct con cell , ( con 1 ( list 2 3 ) ) give list ( 1 2 3 ) argument list , pair creat , repres dot . exampl ( con 1 2 ) give ( 1 . 2 ) con cell consist 1 2 slot instead pointer anoth con cell second slot . name two primit oper decompos list , car cdr , origin come assembl languag macro ibm 704 ; stood `` content address regist '' `` content decrement regist '' respect . # # # data type common data type scheme besid function list : integ , ration , real , complex number , symbol , string , port . scheme implement also offer associ list , hash tabl , vector , array structur . sinc ieee scheme standard r4r scheme standard , scheme assert type disjoint , valu belong one type ; howev ancient implement scheme predat standard # f ' ( ) refer valu , case common lisp . scheme implement offer full numer tower well exact inexact arithmet . true fals repres # # f . actual # f realli fals boolean type requir , everyth els consid true , includ empti list . symbol creat least follow way : 'symbol ( string- > symbol `` symbol '' ) # # # equal scheme three differ type equal : `` eq ? `` return # paramet repres data object memori ; `` eqv ? `` gener eq ? treat object ( eg . charact number ) special number = eqv ? even eq ? ; equal ? compar data structur list , vector string determin congruent structur eqv ? content . type depend equival oper also exist scheme : string= ? ; compar two string ; char= ? compar charact ; = compar number . # # # control structur # # # # condit evalu ( test then-expr else-expr ) test express evalu , evalu result true ( anyth # f ) then-expr evalu , otherwis else-expr evalu . form conveni condit nest cond : ( cond ( test1 expr1 ... ) ( test2 expr2 ... ) ... ( els exprn ) ) first express test evalu true evalu . test result # f , els claus evalu . variant cond claus ( cond ... ( test = > expr ) ... ) case , expr evalu function take one argument . test evalu true , function call return valu test . # # # # loop loop scheme usual take form tail recurs . scheme implement requir optim tail call elimin use stack space possibl , arbitrarili long loop execut use techniqu . classic exampl factori function , defin non-tail-recurs : ( defin ( factori n ) ( ( = n 0 ) 1 ( * n ( factori ( - n 1 ) ) ) ) ) ( factori 5 ) ; ; = > 120 direct translat mathemat recurs definit factori : factori zero ( usual written 0 ! ) equal 1 , factori greater natur number n defin n ! = n * ( n − 1 ) ! . howev , plain recurs natur less effici , sinc scheme system must maintain stack keep track return nest function call . tail-recurs definit one ensur recurs case , outermost call one back top recur function . case , recur factori function , helper routin two paramet repres state iter : ( defin ( factori n ) ( let loop ( ( total 1 ) ( n ) ) ( ( = 0 ) total ( loop ( * total ) ( - 1 ) ) ) ) ) ( factori 5 ) ; ; = > 120 higher order function like map , appli function everi element list , defin non-tail-recurs : ( defin ( map f lst ) ( ( null ? lst ) lst ( con ( f ( car lst ) ) ( map f ( cdr lst ) ) ) ) ) ( map ( lambda ( x ) ( * x x ) ) ' ( 1 2 3 4 ) ) ; ; = > ( 1 4 9 16 ) also defin tail-recurs : ( defin ( map f lst ) ( let loop ( ( lst lst ) ( re ' ( ) ) ) ( ( null ? lst ) ( revers re ) ( loop ( cdr lst ) ( con ( f ( car lst ) ) re ) ) ) ) ) ( map ( lambda ( x ) ( * x x ) ) ' ( 1 2 3 4 ) ) ; ; = > ( 1 4 9 16 ) case tail-recurs version prefer due decreas use space . basic loop , scheme support simpl iter construct : ( ( ( < variable1 > < init1 > < step1 > ) ... ) ( < test > < express > ... ) < command > ... ) exampl : ( let ( ( x ' ( 1 3 5 7 9 ) ) ) ( ( ( x x ( cdr x ) ) ( sum 0 ( + sum ( car x ) ) ) ) ( ( null ? x ) sum ) ) ) # # # input/output scheme concept port read write . r5r defin two default port , access function current-input-port current-output-port , correspond unix notion stdin stdout . implement also provid current-error-port . # # exampl # # # hello world ( begin ( display `` hello , world ! '' ) ( newlin ) ) # # # oop alist ( associ list ) ; ; oop ( object-ori program ) alist ( associ list ) exampl ( defin ( cat-construct age color size ) ; ; constructor ( list ( con 'age age ) ( con 'color colour ) ( con 'size size ) ) ) ; ; cat meow ( age ) time ( defin ( cat-meow cat ) ( let loop ( ( iter ( cdr ( assoc 'age cat ) ) ) ) ( ( > iter 0 ) ( begin ( display `` meow ! \n '' ) ( loop ( - iter 1 ) ) ) ) ) ) ( defin billi ( cat-construct 3 'white 'small ) ) ( display `` billi 's age : `` ) ( display ( cdr ( assoc 'age billi ) ) ) ( newlin ) ( display `` billi 's color : `` ) ( display ( cdr ( assoc 'colour billi ) ) ) ( newlin ) ( cat-meow billi ) scheme code found follow articl : arithmetic-geometr mean church numer continu pass style call-with-current-continu ( aka `` call/cc '' ) curri fibonacci number program wikibook : transwiki : list hello world program infinit loop tail recurs queue quin ( comput )